#summary Frequently anticipated questions
#labels Featured

= General =

== Does "alpha" mean that it's not safe to use? ==

We don't think so! We already use this library extensively in production for services like AdWords, !GMail, Reader, Blogger, Docs & Spreadsheets, and dozens more. We consider it to be pretty safe. However, during the alpha period, we do reserve the right to make changes of any kind to it at any time. So if you use it, when you want to upgrade to the official version you may find that you have some work to do.

== Should I use it in my own library which I release publicly? ==

Sure! But during the alpha period, be very careful. Use it only in the internals of your implementation; don't expose it in your public API. Use [http://tonicsystems.com/products/jarjar/ Jar Jar Links] or a similar tool to make sure your users won't have any conflicts.

Once 1.0 is released, you should be safe to do just about anything with it.

== Why did Google build all this, when it could have tried to improve the Apache Commons Collections instead? ==

The [http://commons.apache.org/collections/ Apache Commons Collections] very clearly did not meet our needs. It does not use generics, which is a problem for us as we hate to get compilation warnings from our code. It has also been in a "holding pattern" for a long time. We could see that it would require a pretty major investment from us to fix it up until we were happy to use it, and in the meantime, our own library was already growing organically.

An important difference between the Apache library and ours is that our collections very faithfully adhere to the contracts specified by the JDK interfaces they implement. If you review the Apache documentation, you'll find countless examples of violations. They deserve credit for pointing these out so clearly, but still, deviating from standard collection behavior is risky! You must be careful what you do with such a collection; bugs are always just waiting to happen.

Our collections are fully generified and never violate their contracts (with isolated exceptions, where JDK implementations have set a strong precedent for acceptable violations). This means you can pass one of our collections to any method that expects a `Collection` and feel pretty confident that things will work exactly as they should.

== Why build on Java 5, instead of 6? ==

Sometime between now and the release of 1.0, we will upgrade to 6. When we do this, we are committed to creating and maintaining a backport branch for Java 5 users.

== Why build on Java 5, instead of 1.4? ==

Because we hate Java 1.4. Just kidding (but we do). Basically, at Google we simply don't use Java 1.4 anymore, and haven't for years. If you're using it, please try feeding our library into [http://retrotranslator.sourceforge.net/ Retrotranslator]. Try out the results, tell us how it goes, and please kindly send us any patches you needed to make to our code to get it working.

== Why won't you let us see your tests? ==

Don't worry, the tests are coming over shortly.

= Design =

== Why so much emphasis on Iterators and Iterables? ==

In general, our methods do not require a Collection to be passed in when an Iterable or Iterator would suffice. This distinction is important to us, as sometimes at Google we work with very large quantities of data, which may be too large to fit in memory, but which can be traversed from beginning to end in the course of some computation. Such data structures can be implemented as Collections that throw exceptions or return wrong answers for most of their methods, but it is a very poor fit, a square peg in a round hole.

An Iterator represents a one-way scrollable stream of elements, and an Iterable is anything which can spawn independent Iterators. A Collection is much, much more than this, so we only require it when we need to.

== Why do the non-Collection Iterables you return implement toString() but not equals() or hashCode()? ==

It's hard to imagine any equals() implementation that would be useful, given that it must return false when given any List or Set (by the transitive property), and would then interfere with the ability of other collection types to define their equals() behavior in a similar way.

It's possible hashCode() would be safe to implement, but it seems pointless. If you have a non-Collection Iterable you want to store in a collection and keep, you want to copy it into a real collection first.

toString() is harmless, though it could take arbitrarily long to run if the data set is huge.

== Why is !AbstractIterator.remove() unsupported, and worse, final? ==

It is impossible to implement correctly without making this simple utility horribly complicated, and even then it would not work for many purposes.

== Why are your collections final? ==

== Why are the names `Multiset` and `Multimap`, not `MultiSet` and `MultiMap`? ==

Because "multiset" is a single, unhyphenated word, and we don't capitalize random letters inside those unless we have a good reason to.

== Aha, but "bimap" is also a single word!  So why is it `BiMap`, not `Bimap`? ==

Well, because we had a good reason to!  :)  A `BiMap` is also a `Map`; it extends the `Map` interface, and we felt it was important to make that connection clear. This is not the case for `Multimap`, nor does `Multiset` extend `Set`.

== Why does `BiMap.put()` throw an exception when the value is already present, instead of just remapping the value? ==

Because this method comes from the Map interface, and such behavior on a `Map` would violate the principle of least surprise. We added the method `BiMap.forcePut()` to offer the behavior described.

== Why is `BiMap.putAll()` is allowed to leave the bimap in an indeterminate state if it throws an exception? ==

In general, a method that throws an exception ought to leave the instance with its state unchanged. However, this is not always feasible. For a typical bimap implementation, it would be downright ugly, and slow. Note that this is no different from the regular behavior of `Map.putAll()`, `Collection.addAll()`, etc.

== Why does `BiMap` have no `getKeyForValue()` method? ==

We did think about it (Doug Lea even half-jokingly suggested naming it `teg()`!). But you don't really need it; just call `inverse().get()`. If this method did exist, every implementor of the interface would have to write it over again, and would probably do it exactly like that.

== `ClassToInstanceMap` is interesting, but I need to map a type `T` to a `Foo<T>` / I need a !ClassToInstanceMultimap / etc. How? ==

If your goal is to maintain type-safety and avoid casts when using the API "normally", but you don't care to go to great lengths to _prevent_ the wrong types of objects being added, it's always been easy to do this yourself:

{{{
  @SuppressWarnings("unchecked")
  public static class ClassToFooMap extends HashMap<Class<?>, Foo<?>> {
    public <T> Foo<T> putInstance(Class<T> type, Foo<T> value) {
      return (Foo<T>) put(type, value);
    }
    public <T> Foo<T> getInstance(Class<T> type) {
      return (Foo<T>) get(type);
    }
  }
}}}

If you want the added protection, you can extend !ForwardingMap and use it in conjunction with `Constraints.constrainedMap()`.

== Why do you use the type `<E extends Comparable>` in various APIs, which is not "fully generified"?  Shouldn't it be `<E extends Comparable<?>>`, `<E extends Comparable<E>>` or `<E extends Comparable<? super E>>`? ==

Many reasons. For one, if we used any of these constructs, you would not be able to use our API with pre-Java-5 objects, like Joda-Time's !DateTime (which we use heavily here). No cast can fix that. Secondly, the "correct" syntax (the last one) does not play nicely with javac's type inference capabilities in certain cases.

The only difference between our type and the "correct" type is that the "correct" construct would not be assignable from a deviant type which was comparable to something, but not comparable to itself, for example `Foo implements Comparable<String>`. In our opinion, creating such a type in the first place is already asking for trouble, as most APIs that accept a `Comparable` elements expect those elements to be mutually comparable.

== Why does `Multimap` have no `putAll(K, Iterable<V>)` or `putAll(Map<K,V>)` methods? ==

These operations can be performed rather simply. First, it's important to realize that the `get(key)` method of `Multimap` returns a "live view" of the collection corresponding to that key. So, `multimap.get(myKey).putAll(myValues)` accomplishes the first task.

The second task is also simple to perform, because any `Map` can be viewed as a `Multimap`: `multimap.putAll(Multimaps.forMap(map))`.

These "workarounds" are simple enough that we did not want to add two additional methods to `Multimap` interface, which is already quite large enough as it is.

== Why do you have your own `@Nullable` annotation, when there's the !JetBrains annotations, and JSR-305 and . . .? ==

We will figure out what to do about this situation before releasing 1.0. We've always seen our `@Nullable` as a stopgap measure only.