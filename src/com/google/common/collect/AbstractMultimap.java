/*
 * Copyright (C) 2007 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.collect;

import com.google.common.base.Nullable;
import com.google.common.base.Objects;

import java.io.Serializable;
import java.util.AbstractCollection;
import java.util.AbstractMap;
import java.util.AbstractSet;
import java.util.Collection;
import java.util.Comparator;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.NoSuchElementException;
import java.util.RandomAccess;
import java.util.Set;
import java.util.SortedSet;

/**
 * Basic implementation of the {@link Multimap} interface. This class represents
 * a multimap as a map that associates each key with a collection of values. All
 * methods of {@link Multimap} are supported, including those specified as
 * optional in the interface.
 *
 * <p>To implement a multimap, a subclass must define the method {@link
 * #createCollection()}, which creates an empty collection of values for a key.
 *
 * <p>The multimap constructor takes a map that has a single entry for each
 * distinct key. When you insert a key-value pair with a key that isn't already
 * in the multimap, {@code AbstractMultimap} calls {@link #createCollection()}
 * to create the collection of values for that key. The subclass should not call
 * {@link #createCollection()} directly, and a new instance should be created
 * every time the method is called.
 *
 * <p>For example, the subclass could pass a {@link java.util.TreeMap} during
 * construction, and {@link #createCollection()} could return a {@link
 * java.util.TreeSet}, in which case the multimap's iterators would propagate
 * through the keys and values in sorted order.
 *
 * <p>Keys and values may be null, as long as the underlying collection classes
 * support nulls.
 *
 * <p>The collections created by {@link #createCollection()} may or may not
 * allow duplicates. If the collection, such as a {@link Set}, does not support
 * duplicates, an added key-value pair will replace an existing pair with the
 * same key and value, if such a pair is present. With collections like {@link
 * List} that allow duplicates, the collection will keep the existing key-value
 * pairs while adding a new pair.
 *
 * <p>This class is not threadsafe when any concurrent operations update the
 * multimap, even if the underlying map and {@link #createCollection()} method
 * return threadsafe classes. Concurrent read operations will work correctly.
 * To allow concurrent update operations, wrap your multimap with a call to
 * {@link Multimaps#synchronizedMultimap}.
 *
 * @author jlevy@google.com (Jared Levy)
 */
public abstract class AbstractMultimap<K,V> implements Multimap<K,V>,
    Serializable {

  /*
   * Here's an outline of the overall design.
   *
   * The map variable contains the collection of values associated with each
   * key. When a key-value pair is added to a multimap that didn't previously
   * contain and values for that key, a new collection generated by
   * createCollection is added to the map. That same collection instance
   * remains in the map as long as the multimap has any values for the key. If
   * all values for the key are removed, the key and collection are removed
   * from the map.
   *
   * The get method returns a WrappedCollection, which decorates the collection
   * in the map (if the key is present) or an empty collection (if the key is
   * not present). When the collection delegate in the WrappedCollection is
   * empty, the multimap may contain subsequently added values for that key. To
   * handle that situation, the WrappedCollection checks whether map contains
   * an entry for the provided key, and if so replaces the delegate.
   *
   * TODO (jlevy): Override Abstract* methods in returned collections to
   * improve performance.
   */
  private static final long serialVersionUID = -2014783599408314531L;

  private Map<K, Collection<V>> map;
  private int totalSize;
  private transient volatile KeySet keySet;
  private transient volatile Collection<Map.Entry<K,V>> entries;
  private transient volatile Collection<V> values;
  private transient volatile Map<K, Collection<V>> asMap;
  private transient volatile Set<Map.Entry<K, Collection<V>>> collectionEntries;
  private transient volatile Multiset<K> multiset;

  /**
   * Creates a new multimap that uses the provided map.
   *
   * @param map place to store the mapping from each key to its corresponding
   *     values
   * @throws IllegalArgumentException if {@code map} is not empty
   */
  protected AbstractMultimap(Map<K, Collection<V>> map) {
    if (map == null) {
      throw new NullPointerException();
    }
    if (!map.isEmpty()) {
      throw new IllegalArgumentException("map parameter must be empty");
    }
    this.map = map;
  }

  /**
   * Creates the collection of values for a particular key.
   *
   * <p>Collections with weak, soft, or phantom references are not
   * supported. Each call to {@code createCollection} should create a new
   * instance.
   *
   * <p>The returned collection class determines whether duplicate key-value
   * pairs are allowed.
   *
   * @return an empty collection of values
   */
  protected abstract Collection<V> createCollection();

  /**
   * Creates the collection of values for an explicitly provided key.
   *
   * <p>By default, it simply calls {@link #createCollection()}, but subclasses
   * such as {@link LinkedHashMultimap} override it.
   *
   * @param key key to associate with values in the collection
   * @return an empty collection of values
   */
  protected Collection<V> createCollection(@Nullable K key) {
    return createCollection();
  }

  public int size() {
    return totalSize;
  }

  public boolean isEmpty() {
    return totalSize == 0;
  }

  public boolean containsKey(@Nullable Object key) {
    return map.containsKey(key);
  }

  public boolean containsValue(@Nullable Object value) {
    for (Collection<V> collection : map.values()) {
      if (collection.contains(value)) {
        return true;
      }
    }

    return false;
  }

  public boolean containsEntry(@Nullable Object key, @Nullable Object value) {
    Collection<V> collection = map.get(key);
    return collection != null && collection.contains(value);
  }

  /**
   * Returns a collection view of all values associated with a key. If no
   * mappings in the multimap have the provided key, an empty collection is
   * returned.
   *
   * <p>The returned collection is modifiable, and updating it will modify the
   * multimap. Multimap updates involving the specified key will change the
   * contents of the returned collection.
   *
   * @param key key to search for in multimap
   * @return collection of values that the key maps to
   */
  public Collection<V> get(@Nullable K key) {
    Collection<V> collection = map.get(key);
    if (collection == null) {
      collection = createCollection(key);
    }
    return wrapCollection(key, collection);
  }

  /**
   * Generates a decorated collection that remains consistent with the values in
   * the multimap for the provided key. Changes to the multimap may alter the
   * returned collection, and visa-versa.
   */
  private Collection<V> wrapCollection(@Nullable K key,
        Collection<V> collection) {
    if (collection instanceof SortedSet) {
      return new WrappedSortedSet(key, (SortedSet<V>) collection, null);
    } else if (collection instanceof Set) {
      return new WrappedSet(key, (Set<V>) collection);
    } else if (collection instanceof List) {
      return wrapList(key, (List<V>) collection, null);
    } else {
      return new WrappedCollection(key, collection, null);
    }
  }

  private List<V> wrapList(@Nullable K key,
      List<V> list, @Nullable WrappedCollection ancestor) {
    return (list instanceof RandomAccess) ?
        new RandomAccessWrappedList(key, list, ancestor) :
        new WrappedList(key, list, ancestor);
  }

  /**
   * Stores a key-value pair in the multimap.
   *
   * <p>Some multimap implementations allow duplicate key-value pairs, in which
   * case {@code put} always adds a new key-value pair and increases the
   * multimap size by 1. Other implementations prohibit duplicates, and {@code
   * put} will replace an existing key-value pair when the keys and values are
   * equal.
   *
   * @param key key to store in the multimap
   * @param value value to store in the multimap
   * @return true if the method increased the size of the multimap,
   *     or false if the multimap already contained the key-value pair and
   *     doesn't allow duplicates
   */
  public boolean put(@Nullable K key, @Nullable V value) {
    Collection<V> collection = getOrCreateCollection(key);

    if (collection.add(value)) {
      totalSize++;
      return true;
    } else {
      return false;
    }
  }

  private Collection<V> getOrCreateCollection(K key) {
    Collection<V> collection = map.get(key);
    if (collection == null) {
      collection = createCollection(key);
      map.put(key, collection);
    }
    return collection;
  }

  /**
   * Stores a collection of values with the same key.
   *
   * <p>Some multimap implementations allow duplicate key-value pairs, in which
   * case {@code putAll} adds a new key-value pair for each element in {@code
   * values} and increases the multimap size by the size of {@code
   * values}. Other implementations prohibit duplicates, and {@code putAll} will
   * replace an existing key-value pair when the keys and values are equal.
   *
   * @param key key to store in the multimap
   * @param values values to store in the multimap
   */
  public void putAll(@Nullable K key, Iterable<? extends V> values) {
    Collection<V> collection = getOrCreateCollection(key);
    int oldSize = collection.size();

    if (values instanceof Collection) {
      collection.addAll((Collection<? extends V>) values);
    } else {
      for (V value : values) {
        collection.add(value);
      }
    }

    totalSize += (collection.size() - oldSize);
    if (collection.isEmpty()) {
      map.remove(key);
    }
  }

  /**
   * Copies all of another multimap's key-value pairs into this multimap. The
   * order in which the mappings are added is determined by
   * {@code multimap.entries()}.
   *
   * <p>Some multimap implementations allow duplicate key-value pairs, in which
   * case {@code putAll} adds a new key-value pair for each mapping in {@code
   * multimap} and increases the multimap size by the size of the supplied
   * {@code multimap}. Other implementations prohibit duplicates, and {@code
   * putAll} will replace an existing key-value pair when the keys and values
   * are equal.
   *
   * @param multimap mappings to store in this multimap
   */
  public void putAll(Multimap<? extends K, ? extends V> multimap) {
    for (Map.Entry<? extends K, ? extends V> entry : multimap.entries()) {
      put(entry.getKey(), entry.getValue());
    }
  }

  /**
   * Stores a collection of values with the same key, replacing any existing
   * values for that key.
   *
   * @param key key to store in the multimap
   * @param values values to store in the multimap
   * @return the collection of replaced values, or an empty collection if no
   *     values were previously associated with the key. The collection is
   *     modifiable, but updating it will have no effect on the multimap.
   */
  public Collection<V> replaceValues(@Nullable K key,
      Iterable<? extends V> values) {
    if (values == null) {
      throw new NullPointerException();
    }

    Collection<V> oldValues = removeAll(key);
    for (V value : values) {
      put(key, value);
    }

    return oldValues;
  }

  /**
   * Removes a key-value pair from the multimap.
   *
   * @param key key of entry to remove from the multimap
   * @param value value of entry to remove the multimap
   * @return true if the multimap changed
   */
  public boolean remove(@Nullable Object key, @Nullable Object value) {
    Collection<V> collection = map.get(key);
    if (collection == null) {
      return false;
    }

    boolean changed = collection.remove(value);
    if (changed) {
      totalSize--;
      if (collection.isEmpty()) {
        map.remove(key);
      }
    }
    return changed;
  }

  /**
   * Removes all values associated with a given key.
   *
   * @param key key of entries to remove from the multimap
   * @return the collection of removed values, or an empty collection if no
   *     values were associated with the provided key. The collection is
   *     modifiable, but updating it will have no effect on the multimap.
   */
  public Collection<V> removeAll(@Nullable Object key) {
    Collection<V> collection = map.remove(key);
    Collection<V> output = createCollection();

    if (collection != null) {
      output.addAll(collection);
      totalSize -= collection.size();
      collection.clear();
    }

    return output;
  }

  /**
   * Removes all key-value pairs from the multimap.
   */
  public void clear() {
    /* Clear each collection, to make previously returned collections empty. */
    for (Collection<V> collection : map.values()) {
      collection.clear();
    }
    map.clear();
    totalSize = 0;
  }

  /**
   * Returns the set of all keys with one or more values.
   *
   * <p>Elements may be removed from the returned set. Changes to the set can
   * alter the multimap and visa-versa.
   *
   * @return the collection of distinct keys
   */
  public Set<K> keySet() {
    if (keySet == null) {
      keySet = new KeySet();
    }
    return keySet;
  }

  /**
   * Returns a collection of all values in the multimap.
   *
   * <p>The iterator generated by the returned collection traverses the values
   * for one key, followed by the values of a second key, and so on.
   *
   * <p>Elements may be removed from the returned collection. Changes to the
   * collection alter the multimap and visa-versa.
   *
   * @return the collection of values, which may include the same value multiple
   *     times if it occurs in multiple mappings
   */
  public Collection<V> values() {
    if (values == null) {
      values = new AbstractCollection<V>() {
        public Iterator<V> iterator() {
          return new ValueIterator();
        }

        public int size() {
          return totalSize;
        }

        /** Included to improve performance. */
        @Override public boolean contains(Object value) {
          return containsValue(value);
        }
      };
    }

    return values;
  }

  /**
   * Returns a collection of all key-value pairs.
   *
   * <p>The iterator generated by the returned collection traverses the values
   * for one key, followed by the values of a second key, and so on.
   *
   * <p>The returned collection supports element removal, which removes the
   * corresponding mapping from the map. It does not support the {@code add} or
   * {@code addAll} operations. Changes to the collection alter the multimap and
   * visa-versa.
   *
   * @return the collection of map entries consisting of key-value pairs, which
   *     in some implementations may include the same key-value entry multiple
   *     times if it occurs in multiple mappings
   */
  public Collection<Map.Entry<K,V>> entries() {
    if (entries == null) {
      entries = (this instanceof SetMultimap) ? new EntrySet() : new Entries();
    }
    return entries;
  }

  /** Entries for multimap. */
  private class Entries extends AbstractCollection<Map.Entry<K,V>> {
    public Iterator<Map.Entry<K,V>> iterator() {
      return createEntryIterator();
    }

    public int size() {
      return totalSize;
    }

    /* The following methods are included to improve performance. */
    @Override public boolean contains(Object entry) {
      return (entry instanceof Map.Entry) &&
          containsEntry(
              ((Map.Entry) entry).getKey(), ((Map.Entry) entry).getValue());
    }

    @Override public void clear() {
      AbstractMultimap.this.clear();
    }
  }

  /** Entry set for a {@link SetMultimap}. */
  private class EntrySet extends Entries implements Set<Map.Entry<K,V>> {
    @Override public boolean equals(Object other) {
      if (this == other) {
        return true;
      }
      if (!(other instanceof Set)) {
        return false;
      }
      Set<?> otherSet = (Set<?>) other;
      return (totalSize == otherSet.size()) && containsAll(otherSet);
    }

    @Override public int hashCode() {
      int hash = 0;
      for (Map.Entry<K,V> entry : this) {
        hash+= entry.hashCode();
      }
      return hash;
    }
  }

  public Map<K, Collection<V>> asMap() {
    if (asMap == null) {
      asMap = new AbstractMap<K, Collection<V>>() {
        public Set<Map.Entry<K, Collection<V>>> entrySet() {
          return collectionEntries();
        }

        /* The following methods are included for performance. */

        @Override public boolean containsKey(Object key) {
          return map.containsKey(key);
        }

        @SuppressWarnings("unchecked")
        @Override public Collection<V> get(Object key) {
          Collection<V> collection = map.get(key);
          return (collection == null)
              ? null : wrapCollection((K) key, collection);
        }

        @Override public Collection<V> remove(Object key) {
          Collection<V> collection = removeAll(key);
          return collection.isEmpty() ? null : collection;
        }

        @Override public boolean equals(Object other) {
          return map.equals(other);
        }

        @Override public int hashCode() {
          return map.hashCode();
        }

        @Override public String toString() {
          return map.toString();
        }
      };
    }

    return asMap;
  }

  public Set<Map.Entry<K, Collection<V>>> collectionEntries() {
    if (collectionEntries == null) {
      collectionEntries = new AbstractSet<Map.Entry<K, Collection<V>>>() {
        @Override public Iterator<Map.Entry<K, Collection<V>>> iterator() {
          return new CollectionIterator();
        }

        @Override public int size() {
          return map.size();
        }
      };
    }

    return collectionEntries;
  }

  /**
   * Returns a collection, which may contain duplicates, of all keys. The number
   * of times of key appears in the returned collection equals the number of
   * mappings the key has in the multimap.
   *
   * @return the multiset of keys corresponding to the distinct keys of the
   *     multimap and frequencies corresponding to the number of values that
   *     each key maps to
   * @see #keySet
   */
  public Multiset<K> keys() {
    if (multiset == null) {
      multiset = new MultisetView();
    }
    return multiset;
  }

  /**
   * Generates a string representation of the multimap.
   *
   * <p>It calls the {@code toString} methods of the class of the underlying map
   * and that returned by {@code createCollection()}, which determine the format
   * of the generated string.
   *
   * @return a string representation of the multimap
   */
  @Override public String toString() {
    return map.toString();
  }

  @Override public boolean equals(@Nullable Object other) {
    if (this == other) {
      return true;
    }
    if (!(other instanceof Multimap)) {
      return false;
    }
    Multimap<?,?> otherMultimap = (Multimap<?,?>) other;
    return map.equals(otherMultimap.asMap());
  }

  /**
   * Returns the hash code for this multimap.
   *
   * <p>The hash code is determined by summing, over each {@code key} in the
   * multimap, the expression
   *
   * <pre>  ((key == null) ? 0 : key.hashCode()) ^ get(key).hashCode()</pre>
   *
   * @return the hash code for this multimap
   */
  @Override public int hashCode() {
    return map.hashCode();
  }

  private Iterator<V> iteratorOrListIterator(Collection<V> collection) {
    return (collection instanceof List) ?
        ((List<V>) collection).listIterator() :
        collection.iterator();
  }

  /**
   * Returns an iterator across all key-value map entries, used by {@code
   * entries().iterator()} and {@code values().iterator()}. The default
   * behavior, which traverses the values for one key, the values for a second
   * key, and so on, suffices for most {@code AbstractMultimap} implementations.
   *
   * @return An iterator across map entries
   */
  protected Iterator<Map.Entry<K,V>> createEntryIterator() {
    return new EntryIterator();
  }

  /** Iterator across all key-value pairs. */
  private class EntryIterator implements Iterator<Map.Entry<K,V>> {
    private final Iterator<Map.Entry<K, Collection<V>>> keyIterator;
    private K key;
    private Collection<V> collection;
    private Iterator<V> valueIterator;

    public EntryIterator() {
      keyIterator = map.entrySet().iterator();
      if (keyIterator.hasNext()) {
        findValueIteratorAndKey();
      } else {
        valueIterator = Iterators.emptyIterator();
      }
    }

    private void findValueIteratorAndKey() {
      Map.Entry<K, Collection<V>> entry = keyIterator.next();
      key = entry.getKey();
      collection = entry.getValue();
      valueIterator = iteratorOrListIterator(collection);
    }

    public boolean hasNext() {
      return valueIterator.hasNext() || keyIterator.hasNext();
    }

    public Map.Entry<K,V> next() {
      if (!hasNext()) {
        throw new NoSuchElementException();
      }
      if (!valueIterator.hasNext()) {
        findValueIteratorAndKey();
      }

      return (valueIterator instanceof ListIterator) ?
          new ListMapEntry(key, (ListIterator<V>) valueIterator) :
          Maps.immutableEntry(key, valueIterator.next());
    }

    public void remove() {
      valueIterator.remove();
      if (collection.isEmpty()) {
        keyIterator.remove();
      }
      totalSize--;
    }
  }

  /**
   * Map entry that allows value modification through provided list iterator.
   */
  private class ListMapEntry extends AbstractMapEntry<K,V> {
    private final K key;
    private V value;
    private final ListIterator<V> iterator;

    public ListMapEntry(K key, ListIterator<V> iterator) {
      this.key = key;
      this.value = iterator.next();
      this.iterator = iterator;
    }

    public K getKey() {
      return key;
    }

    public V getValue() {
      return value;
    }

    public V setValue(V newValue) {
      V oldValue = this.value;
      iterator.set(newValue);
      this.value = newValue;
      return oldValue;
    }
  }

  /** Iterator across all values. */
  private class ValueIterator implements Iterator<V> {
    private Iterator<Entry<K,V>> entryIterator = createEntryIterator();

    public boolean hasNext() {
      return entryIterator.hasNext();
    }

    public V next() {
      return entryIterator.next().getValue();
    }

    public void remove() {
      entryIterator.remove();
    }
  }

  /** Iterator across all keys and value collections. */
  private class CollectionIterator implements
      Iterator<Map.Entry<K, Collection<V>>> {
    private final Iterator<Map.Entry<K, Collection<V>>> delegateIterator =
        map.entrySet().iterator();
    private Collection<V> collection;

    public boolean hasNext() {
      return delegateIterator.hasNext();
    }

    public Entry<K, Collection<V>> next() {
      Map.Entry<K, Collection<V>> entry = delegateIterator.next();
      K key = entry.getKey();
      collection = entry.getValue();
      return Maps.immutableEntry(key, wrapCollection(key, collection));
    }

    public void remove() {
      delegateIterator.remove();
      totalSize -= collection.size();
      collection.clear();
    }
  }

  /**
   * Collection decorator that stays in sync with the multimap values for a key.
   * There are two kinds of wrapped collections: full and subcollections. Both
   * have a delegate pointing to the underlying collection class.
   *
   * <p>Full collections, identified by a null ancestor field, contain all
   * multimap values for a given key. Its delegate is a value in {@link
   * AbstractMultimap#map} whenever the delegate is non-empty. The {@code
   * refreshIfEmpty}, {@code removeIfEmpty}, and {@code addToMap} methods ensure
   * that the WrappedCollection and map remain consistent.
   *
   * <p>A subcollection, such as a sublist, contains some of the values for a
   * given key. Its ancestor field points to the full wrapped collection with
   * all values for the key. The subcollection {@code refreshIfEmpty}, {@code
   * removeIfEmpty}, and {@code addToMap} methods call the corresponding methods
   * of the full wrapped collection.
   */
  private class WrappedCollection extends AbstractCollection<V> {
    private final K key;
    private Collection<V> delegate;
    private final WrappedCollection ancestor;
    private final Collection<V> originalAncestorDelegate;

    public WrappedCollection(@Nullable K key, Collection<V> delegate,
        @Nullable WrappedCollection ancestor) {
      this.key = key;
      this.delegate = delegate;
      this.ancestor = ancestor;
      this.originalAncestorDelegate =
          (ancestor == null) ? null : ancestor.getDelegate();
    }

    /**
     * If the delegate collection is empty, but the multimap has values for the
     * key, replace the delegate with the new collection for the key.
     *
     * <p>For a subcollection, refresh its ancestor and validate that the
     * ancestor delegate hasn't changed.
     */
    protected void refreshIfEmpty() {
      if (ancestor != null) {
        ancestor.refreshIfEmpty();
        if (ancestor.getDelegate() != originalAncestorDelegate) {
          throw new ConcurrentModificationException();
        }
      } else if (delegate.isEmpty()) {
        Collection<V> newDelegate = map.get(key);
        if (newDelegate != null) {
          delegate = newDelegate;
        }
      }
    }

    /**
     * If collection is empty, remove it from {@code map}. For subcollections,
     * check whether the ancestor collection is empty.
     */
    protected void removeIfEmpty() {
      if (ancestor != null) {
        ancestor.removeIfEmpty();
      } else if (delegate.isEmpty()) {
        map.remove(key);
      }
    }

    protected K getKey() {
      return key;
    }

    /**
     * Add the delegate to the map. Other {@code WrappedCollection} methods
     * should call this method after adding elements to a previously empty
     * collection.
     *
     * <p>Subcollection add the ancestor's delegate instead.
     */
    protected void addToMap() {
      if (ancestor != null) {
        ancestor.addToMap();
      } else {
        /*
         * If someone calls get() with a key that isn't an instance of K and
         * subsequently adds a value to the returned collection, an invalid key
         * will be added to the multimap.
         */
        map.put(key, delegate);
      }
    }

    @Override public int size() {
      refreshIfEmpty();
      return delegate.size();
    }

    @Override public boolean equals(Object other) {
      refreshIfEmpty();
      return delegate.equals(other);
    }

    @Override public int hashCode() {
      refreshIfEmpty();
      return delegate.hashCode();
    }

    @Override public String toString() {
      refreshIfEmpty();
      return delegate.toString();
    }

    protected Collection<V> getDelegate() {
      return delegate;
    }

    @Override public Iterator<V> iterator() {
      refreshIfEmpty();
      return new WrappedIterator();
    }

    /**
     * Collection iterator for {@code WrappedCollection}.
     */
    protected class WrappedIterator implements Iterator<V> {
      private final Iterator<V> delegateIterator;
      private final Collection<V> originalDelegate = delegate;

      public WrappedIterator() {
        delegateIterator = iteratorOrListIterator(delegate);
      }

      public WrappedIterator(Iterator<V> delegateIterator) {
        this.delegateIterator = delegateIterator;
      }

      /**
       * If the delegate changed since the iterator was created, the iterator
       * is no longer valid.
       */
      protected void validateIterator() {
        refreshIfEmpty();
        if (delegate != originalDelegate) {
          throw new ConcurrentModificationException();
        }
      }

      public boolean hasNext() {
        validateIterator();
        return delegateIterator.hasNext();
      }

      public V next() {
        validateIterator();
        return delegateIterator.next();
      }

      public void remove() {
        delegateIterator.remove();
        totalSize--;
        removeIfEmpty();
      }

      protected Iterator<V> getDelegateIterator() {
        validateIterator();
        return delegateIterator;
      }
    }

    @Override public boolean add(V value) {
      refreshIfEmpty();
      boolean wasEmpty = delegate.isEmpty();
      boolean changed = delegate.add(value);
      if (changed) {
        totalSize++;
        if (wasEmpty) {
          addToMap();
        }
      }
      return changed;
    }

    /* The following methods are provided for better performance. */

    @Override public boolean contains(Object o) {
      refreshIfEmpty();
      return delegate.contains(o);
    }

    @Override public boolean remove(Object o) {
      refreshIfEmpty();
      boolean changed = delegate.remove(o);
      if (changed) {
        totalSize--;
        removeIfEmpty();
      }
      return changed;
    }

    @Override public boolean containsAll(Collection<?> c) {
      refreshIfEmpty();
      return delegate.containsAll(c);
    }

    @Override public void clear() {
      int oldSize = size();  // calls refreshIfEmpty
      if (oldSize == 0) {
        return;
      }
      delegate.clear();
      totalSize -= oldSize;
      removeIfEmpty();       // maybe shouldn't be removed if this is a sublist
    }

    protected WrappedCollection getAncestor() {
      return ancestor;
    }
  }

  /**
   * Set decorator that stays in sync with the multimap values for a key.
   */
  private class WrappedSet extends WrappedCollection implements Set<V> {
    public WrappedSet(@Nullable K key, Set<V> delegate) {
      super(key, delegate, null);
    }
  }

  /**
   * SortedSet decorator that stays in sync with the multimap values for a key.
   */
  private class WrappedSortedSet extends WrappedCollection
      implements SortedSet<V> {
    public WrappedSortedSet(@Nullable K key, SortedSet<V> delegate,
        @Nullable WrappedCollection ancestor) {
      super(key, delegate, ancestor);
    }

    private SortedSet<V> getSortedSetDelegate() {
      return (SortedSet<V>) getDelegate();
    }

    public Comparator<? super V> comparator() {
      refreshIfEmpty();
      return getSortedSetDelegate().comparator();
    }

    public V first() {
      refreshIfEmpty();
      return getSortedSetDelegate().first();
    }

    public V last() {
      refreshIfEmpty();
      return getSortedSetDelegate().last();
    }

    public SortedSet<V> headSet(V toElement) {
      refreshIfEmpty();
      return new WrappedSortedSet(getKey(),
          getSortedSetDelegate().headSet(toElement),
          (getAncestor() == null) ? this : getAncestor());
    }

    public SortedSet<V> subSet(V fromElement, V toElement) {
      refreshIfEmpty();
      return new WrappedSortedSet(getKey(),
          getSortedSetDelegate().subSet(fromElement, toElement),
          (getAncestor() == null) ? this : getAncestor());
    }

    public SortedSet<V> tailSet(V fromElement) {
      refreshIfEmpty();
      return new WrappedSortedSet(getKey(),
          getSortedSetDelegate().tailSet(fromElement),
          (getAncestor() == null) ? this : getAncestor());
    }
  }

  /**
   * List decorator that stays in sync with the multimap values for a key.
   */
  private class WrappedList extends WrappedCollection
      implements List<V> {

    public WrappedList(@Nullable K key, List<V> delegate,
        @Nullable WrappedCollection ancestor) {
      super(key, delegate, ancestor);
    }

    private List<V> getListDelegate() {
      return (List<V>) getDelegate();
    }

    public boolean addAll(int index, Collection<? extends V> c) {
      if (c.isEmpty()) {
        return false;
      }
      refreshIfEmpty();

      int oldSize = getListDelegate().size();
      boolean changed = getListDelegate().addAll(index, c);
      int newSize = getListDelegate().size();
      totalSize += (newSize - oldSize);
      if (oldSize == 0) {
        addToMap();
      }
      return changed;
    }

    public V get(int index) {
      refreshIfEmpty();
      return getListDelegate().get(index);
    }

    public V set(int index, V element) {
      refreshIfEmpty();
      return getListDelegate().set(index, element);
    }

    public void add(int index, V element) {
      refreshIfEmpty();
      boolean wasEmpty = getListDelegate().isEmpty();
      getListDelegate().add(index, element);
      totalSize++;
      if (wasEmpty) {
        addToMap();
      }
    }

    public V remove(int index) {
      refreshIfEmpty();
      V value = getListDelegate().remove(index);
      totalSize--;
      removeIfEmpty();
      return value;
    }

    public int indexOf(Object o) {
      refreshIfEmpty();
      return getListDelegate().indexOf(o);
    }

    public int lastIndexOf(Object o) {
      refreshIfEmpty();
      return getListDelegate().lastIndexOf(o);
    }

    public ListIterator<V> listIterator() {
      refreshIfEmpty();
      return new WrappedListIterator();
    }

    public ListIterator<V> listIterator(int index) {
      refreshIfEmpty();
      return new WrappedListIterator(index);
    }

    public List<V> subList(int fromIndex, int toIndex) {
      refreshIfEmpty();
      return wrapList(getKey(), getListDelegate().subList(fromIndex, toIndex),
          (getAncestor() == null) ? this : getAncestor());
    }

    /**
     * ListIterator decorator.
     */
    private class WrappedListIterator extends WrappedIterator
        implements ListIterator<V> {
      public WrappedListIterator() {
      }

      public WrappedListIterator(int index) {
        super(getListDelegate().listIterator(index));
      }

      private ListIterator<V> getDelegateListIterator() {
         return (ListIterator<V>) getDelegateIterator();
      }

      public boolean hasPrevious() {
        return getDelegateListIterator().hasPrevious();
      }

      public V previous() {
        return getDelegateListIterator().previous();
      }

      public int nextIndex() {
        return getDelegateListIterator().nextIndex();
      }

      public int previousIndex() {
        return getDelegateListIterator().previousIndex();
      }

      public void set(V value) {
        getDelegateListIterator().set(value);
      }

      public void add(V value) {
        boolean wasEmpty = isEmpty();
        getDelegateListIterator().add(value);
        totalSize++;
        if (wasEmpty) {
          addToMap();
        }
      }
    }
  }

  private class KeySet extends AbstractSet<K> {
    @Override public int size() {
      return map.size();
    }

    @Override public Iterator<K> iterator() {
      return new Iterator<K>() {
        private final Iterator<Entry<K, Collection<V>>> entryIterator =
            map.entrySet().iterator();
        private Entry<K, Collection<V>> entry;

        public boolean hasNext() {
          return entryIterator.hasNext();
        }

        public K next() {
          entry = entryIterator.next();
          return entry.getKey();
        }

        public void remove() {
          entryIterator.remove();
          totalSize-= entry.getValue().size();
          entry.getValue().clear();
        }
      };
    }

    /* The following methods are included for better performance. */
    @Override public boolean contains(Object key) {
      return map.containsKey(key);
    }

    @Override public boolean remove(Object key) {
      return !AbstractMultimap.this.removeAll(key).isEmpty();
    }

    @Override public boolean containsAll(Collection<?> c) {
      return map.keySet().containsAll(c);
    }

    @Override public void clear() {
      AbstractMultimap.this.clear();
    }
  }

  /**
   * List decorator that stays in sync with the multimap values for a key and
   * supports rapid random access.
   */
  private class RandomAccessWrappedList extends WrappedList
      implements RandomAccess {
    public RandomAccessWrappedList(@Nullable K key, List<V> delegate,
        @Nullable WrappedCollection ancestor) {
      super(key, delegate, ancestor);
    }
  }

  /**
   * Multiset view that stays in sync with the multimap keys.
   */
  private class MultisetView extends AbstractCollection<K>
      implements Multiset<K> {
    private transient volatile Set<Multiset.Entry<K>> entrySet;

    public int count(Object key) {
      Collection collection = map.get(key);
      return (collection == null) ? 0 : collection.size();
    }

    public boolean add(K key, int occurrences) {
      throw new UnsupportedOperationException();
    }

    public int remove(Object key, int occurrences) {
      Collection<V> collection = map.get(key);
      if (collection == null) {
        return 0;
      }
      int count = collection.size();

      if (occurrences >= count) {
        AbstractMultimap.this.removeAll(key);
        return count;
      }

      Iterator<V> iterator = collection.iterator();
      for (int i=0; i<occurrences; i++) {
        iterator.next();
        iterator.remove();
      }
      totalSize-= occurrences;
      return occurrences;
    }

    public int removeAllOccurrences(Object key) {
      return AbstractMultimap.this.removeAll(key).size();
    }

    public Set<K> elementSet() {
      return AbstractMultimap.this.keySet();
    }

    public Set<Multiset.Entry<K>> entrySet() {
      if (entrySet == null) {
        entrySet = new AbstractSet<Multiset.Entry<K>>() {
          @Override public Iterator<Multiset.Entry<K>> iterator() {
            return new MultisetEntryIterator();
          }

          @Override public int size() {
            return map.size();
          }
        };
      }

      return entrySet;
    }

    @Override public String toString() {
      return entrySet().toString();
    }

    @Override public int hashCode() {
      return entrySet().hashCode();
    }

    @Override public boolean equals(Object other) {
      if (this == other) {
        return true;
      }
      if (!(other instanceof Multiset)) {
        return false;
      }
      return entrySet().equals(((Multiset) other).entrySet());
    }

    @Override public Iterator<K> iterator() {
      return new MultisetKeyIterator();
    }

    @Override public int size() {
      return totalSize;
    }
  }

  /**
   * Iterator across each key, repeating once per value.
   */
  private class MultisetEntryIterator implements Iterator<Multiset.Entry<K>> {
    private final Iterator<Entry<K, Collection<V>>> collectionIterator =
        collectionEntries().iterator();

    public boolean hasNext() {
      return collectionIterator.hasNext();
    }

    public Multiset.Entry<K> next() {
      return new MultisetEntry(collectionIterator.next());
    }

    public void remove() {
      collectionIterator.remove();
    }
  }

  private class MultisetEntry implements Multiset.Entry<K> {
    private final Entry<K, Collection<V>> entry;

    public MultisetEntry(Entry<K, Collection<V>> entry) {
      this.entry = entry;
    }

    private void validate() {
      if (entry.getValue().isEmpty()) {
        throw new ConcurrentModificationException();
      }
    }

    public K getElement() {
      validate();
      return entry.getKey();
    }

    public int getCount() {
      validate();
      return entry.getValue().size();
    }

    @Override public String toString() {
      int count = getCount();
      String keyString = String.valueOf(entry.getKey());
      return (count == 1) ? keyString : keyString + " x " + count;
    }

    @Override public boolean equals(Object other) {
      if (this == other) {
        return true;
      }
      if (!(other instanceof Multiset.Entry<?>)) {
        return false;
      }
      Multiset.Entry<?> that = (Multiset.Entry<?>) other;
      if (this.getCount() != that.getCount()) {
        return false;
      }
      return Objects.equal(entry.getKey(), that.getElement());
    }

    @Override public int hashCode() {
      return ((entry.getKey() == null) ? 0 : entry.getKey().hashCode()) ^
          getCount();
    }
  }

  /**
   * Iterator across each key, repeating once per value.
   */
  private class MultisetKeyIterator implements Iterator<K> {
    private final Iterator<Entry<K,V>> entryIterator = entries().iterator();

    public boolean hasNext() {
      return entryIterator.hasNext();
    }

    public K next() {
      return entryIterator.next().getKey();
    }

    public void remove() {
      entryIterator.remove();
    }
  }
}
